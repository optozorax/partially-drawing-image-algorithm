#pragma once

/**
	Имеется задача: получить некоторые N% пикселей и увидеть приближенный результат итого изображения, имея только эти пиксели. 
		Например, нам передается изображения через интернет. Как нам его надо передавать и кодировать, чтобы при очень медленном соединении получить приблизительный вид картинки? 
		Или, например, у нас рендерится изображение. И на один пиксель тратится очень много вычислений. Все изображение может рендерится часами. И хотелось бы видеть всю картинку, даже в очень нечетком качестве, когда отрендерилось лишь 2%.
	Такая возможность обеспечивается двумя классами:
		Класс обхода пикселей - TravelPoints.
		Класс заливки недогруженного изображения - FillHalfrend (Fill Half Rendered).
	Класс обхода пикселей задает в каком порядке необходимо просчитывать или передавать пиксели, чтобы работал алгоритм заливки. Получается ваш рендеринг изображения, или передача картки по интернету, должно происходить в такой последовательности, как диктует TravelPoints.
	Класс заливки получает изображение, закрашенное методом, описанным выше(незакрашенные пиксели должны быть Transparent). И закрашивает его с помощью интерполяции, чтобы изображение выглядело приближенно похоже на то, что будет.

	Пример:
		double percent = 0.22;

		ImageBase img(Point_i(1000, 1000));
		img.clear(Transparent);

		TravelPoints trvl;
		trvl.compute(img.size());
		
		for (int i = 0; i < trvl.size() * percent; ++i)
			img[trvl.get(i)] = renderPixel(trvl.get(i));

		FillHalfrend::fill(img);

	Плюсы:
		+ Уже на 2% изображения, обладающего плавными переходами, можно различить общие детали
		+ Относительно высокая скорость - изображение на весь экран будет закрашиваться максимум 100 мс
		+ Точки можно рассчитать заранее и хранить
		+ Каждый пиксель изображения в итоге будет пройден только один раз, то, когда вы захотите посмотреть на промежуточный результат, зависит только от вас.
	Минусы:
		- Требует много памяти. Количество всех пикселей = N. Потребляемая память ~ 4 * N.
		- Последовательность обхода пикселей не распределена равномерно, как, например, случайные числа. БОльшая часть отрендеренных для некоторого процента пикселей приходится на правый нижний угол. Это минус алгоритма закраски.
		- Алгоритм закраски и обхода пикселей неразрывно связаны. Один не может работать без другого, и не имеет смысла без него. 

	Общий принцип работы алгоритма получения пикселей обхода в необходимом порядке:
		Массив частей изображения.push_back(все изображение)
		Повторять, пока ни одна часть не будет по размерам равна пикселю
			Каждая часть изображения делится на 4 одинаковых части(если по некоторой координате нельзя разделить на две разные части, то вся часть делится на две части).
			В массив пикселей обхода добавляются пиксели каждой полученной части.
				Делается это так, чтобы не было коллизий с уже полученными пикселями.
			Старые части изображения удаляются, теперь работаем с новыми.

	При таком алгоритме получается, что у каждого пикселя всегда есть правый и нижний сосед, который закрашен(кроме, конечно, границ, там отдельно обрабатывается). При этом на пересечении вертикали правого соседа и горизонтали нижнего соседа всегда есть еще один закрашенный пиксель. И при этом между всеми этими четырьмя пикселями никогда нету неожиданного закрашенного пикселя. Все пиксели между ними не закрашены.

	На этом свойстве такого обхода базируется закраска. Она для каждого пикселя находит соседей и закрашивает пространство между ними градиентом из четырех пикселей. Закраска реализуется рекурсивно. При этом имеется массив коллизий, чтобы находить, обрабатывался ли уже этот пиксель.

	Для более подробной информации можно заглянуть в код. Там алгоритмы уже оптимизированы для большего быстродействия, поэтому воспринять их может быть сложнее, и они могут немного отличаться от описанного здесь.
		
 */

#include <twg/twg.h>
#include <vector>

class FillHalfrend;
class TravelPoints;

//-----------------------------------------------------------------------------
/**
	Класс, обеспечивающий закраску изображения, полученного специальным обходом.
 */
class FillHalfrend
{
public:
	static void fill(twg::ImageBase& img);
private:
	static void m_fill(twg::ImageBase& img, twg::Point_i p);
	static std::vector<bool> m_processed;
};

//-----------------------------------------------------------------------------
/**
	Класс, обеспечивающий особый обход пикселей двумерного изображения.
 */
class TravelPoints
{
public:
	void compute(twg::Point_i newSize);

	twg::Point_i get(int i) const;
	int size(void) const;
private:
	std::vector<twg::Point_i> m_pmas;
};